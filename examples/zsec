#!/usr/bin/env bash

set -eo pipefail

### SET COLOR CODES ###
RED=$(tput setaf 1)
GREEN=$(tput setaf 2)
YELLOW=$(tput setaf 3)
CYAN=$(tput setaf 6)
RESET=$(tput sgr0)

usage()
{
    echo "Usage: $0 <${GREEN}up${RESET}|${RED}destroy${RESET}>"
    exit 1
}

if [ $# -ne 1 ] ; then
    usage
else
    case $1 in
      up|destroy|do)
          oper=$1
      ;;
      *)
          usage
      ;;
    esac
fi

if [[ "$oper" == "up" && ! -e ./.zsecrc ]]; then
    PS3="${CYAN}Select your Zscaler Cloud: ${RESET}"
    zs_clouds=("zscloud.net" "zscaler.net" "zscalertwo.net" "zscalerthree.net" "zscalerten.net" "zscalergov.net" "zscalerbeta.net" "other")
    select zscaler_cloud in "${zs_clouds[@]}"
    do
        case $REPLY in
            1)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            2)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            3)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            4)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            5)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            6)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            7)
                echo "Zscaler Cloud ${GREEN}$zscaler_cloud${RESET} selected"
                zscaler_cloud=$zscaler_cloud
                break
                ;;
            8)
                echo "Zscaler Cloud ${YELLOW}$zscaler_cloud${RESET} selected"
                while true; do
                    read -r -p "${CYAN}Enter your desired Zscaler Cloud name (e.g. zscalerbeta.net): ${RESET}" manual_cloud_name_response
                    case $manual_cloud_name_response in
                        zspreview|zscalerpreview|preview|zspreview.net|zscalerpreview.net|preview.net )
                            echo "Setting zspreview.net"
                            zscaler_cloud=zspreview.net
                            zs_env=development
                            break
                            ;;
                        zsdevel|zscalerdevel|devel|zsdevel.net|zscalerdevel.net|devel.net )
                            echo "Setting zsdevel.net"
                            zscaler_cloud=zsdevel.net
                            zs_env=development
                            break
                            ;;
                        zsqa|zscalerqa|qa|zsqa.net|zscalerqa.net|qa.net )
                            echo "Setting zsqa.net"
                            zscaler_cloud=zsqa.net
                            zs_env=development
                            break
                            ;;
                        *) 
                            echo "${RED}Invalid response. Please enter a valid Zscaler Cloud name${RESET}"
                    esac
                done
                break
                ;;
            *) 
                echo "${RED}Invalid response. Please enter a number selection${RESET}"
        esac
    done
fi

if [[ "$oper" == "up" ]]; then
    if [[ -e ./.zsecrc ]]; then
        echo "${YELLOW}Existing deployment configuration file identified...${RESET}"
        # initialize environment variables
        . ./.zsecrc
        echo "Refreshing Deployment Type: ${GREEN}$dtype${RESET}..." 
    else #Prompt for deployment selection
        PS3="${CYAN}Select desired deployment: ${RESET}"
        deployments=("greenfield - Recommended for isolated test/POV deployments. Creates new network infrastructure, test workloads, and a public jump host" "brownfield - Recommended for prod deployments. Bring-your-own existing network infrastructure customizations + no workload/bastion creation")
        select deployment in "${deployments[@]}"
        do
            case $REPLY in
                1)
                    echo "${GREEN}Greenfield deployment selected...${RESET}"
                    echo "${YELLOW}**Caution** These deployments include test workloads and publicly accessible jump hosts and are intended primarily for lab/test environments${RESET}"
                    echo ""
                    deployment=greenfield
                break
                ;;
                2)
                    echo "${GREEN}Brownfield deployment selected...${RESET}"
                    deployment=brownfield
                break
                ;;
                *) 
                    echo "${RED}Invalid response. Please enter a number selection${RESET}"
            esac
        done
        
        if [[ "$zscaler_cloud" == "zscalerten.net" ]]; then
            echo "${YELLOW}Zscalerten does not currently support Auto Scaling VMSS. Proceeding with standard deployment options...${RESET}"
            if [[ "$deployment" == "greenfield" ]]; then 
                vmss_enabled=false
            elif [[ "$deployment" == "brownfield" ]]; then
                echo "${GREEN}Proceeding with brownfield manual scaling with load balancer configuration...${RESET}"
                vmss_enabled=false
                #implicitly set dtype as cc_lb for brownfield + no vmss
                dtype=cc_lb
            fi
        else
            while true; do
                read -r -p "${CYAN}Deploy Cloud Connectors in Auto Scaling VMSS? [yes/no]: ${RESET}" response
                case $response in 
                yes|y )
                    if [[ "$deployment" == "greenfield" ]]; then 
                        echo "${GREEN}Proceeding with greenfield Virtual Machine Scale Sets configuration...${RESET}"
                        vmss_enabled=true
                    elif [[ "$deployment" == "brownfield" ]]; then
                        echo "${GREEN}Proceeding with brownfield Virtual Machine Scale Sets configuration...${RESET}"
                        vmss_enabled=true
                        #implicitly set dtype as cc_vmss for brownfield + vmss
                        dtype=cc_vmss
                    fi
                break
                ;;
                no|n )
                    if [[ "$deployment" == "greenfield" ]]; then 
                        echo "${GREEN}Proceeding with greenfield manual scaling configuration...${RESET}"
                        vmss_enabled=false
                    elif [[ "$deployment" == "brownfield" ]]; then
                        echo "${GREEN}Proceeding with brownfield manual scaling with load balancer configuration...${RESET}"
                        vmss_enabled=false
                        #implicitly set dtype as cc_lb for brownfield + no vmss
                        dtype=cc_lb
                    fi
                break
                ;;
                    * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done
        fi
    fi      

    if [[ "$deployment" == "greenfield" ]]; then
        PS3="${CYAN}Select desired deployment type: ${RESET}"
        if [[ "$vmss_enabled" == "false" ]]; then
            dtypes=(
                "Deploy 1 Cloud Connector in a new Resource Group and VNet"
                "Deploy 1 Cloud Connector in a new Resource Group and VNet w/ Private DNS for ZPA"
                "Deploy multiple Cloud Connectors w/ Load Balancer in a new Resource Group and VNet"
                "Deploy multiple Cloud Connectors w/ Load Balancer in a new Resource Group and VNet w/ Private DNS for ZPA"
                "Deploy a new Resource Group and VNet only - No Cloud Connector resources"  
            )
            select greenfield_type in "${dtypes[@]}"
            do
                case $REPLY in
                    1)
                        echo "Deployment type base_1cc selected..."
                        dtype=base_1cc
                        break
                        ;;
                    2)
                        echo "Deployment type base_1cc_zpa selected..."
                        dtype=base_1cc_zpa
                        break
                        ;;
                    3)
                        echo "Deployment type base_cc_lb selected..."
                        dtype=base_cc_lb
                        break
                        ;;
                    4)
                        echo "Deployment type base_cc_lb_zpa selected..."
                        dtype=base_cc_lb_zpa
                        break
                        ;;
                    5)
                        echo "Deployment type base selected..."
                        dtype=base
                        break
                        ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                esac
            done
        elif [[ "$vmss_enabled" == "true" ]]; then
            dtypes=(
                "Deploy Virtual Machine Scale Set of Cloud Connectors w/ Load Balancer in a new Resource Group and VNet"
                "Deploy Virtual Machine Scale Set of Cloud Connectors w/ Load Balancer in a new Resource Group and VNet w/ Private DNS for ZPA"
            )
            select greenfield_type in "${dtypes[@]}"
            do
                case $REPLY in
                    1)
                        echo "Deployment type base_cc_vmss selected..."
                        dtype=base_cc_vmss
                        break
                        ;;
                    2)
                        echo "Deployment type base_cc_vmss_zpa selected..."
                        dtype=base_cc_vmss_zpa
                        break
                        ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                esac
            done
        fi
    else
        dtype=$dtype
    fi
fi

echo "Discovering processor architecture..."
archdetect=$(uname -m)

tversion=1.1.9
echo "Detecting OS..."
if [[ "$OSTYPE" == "linux"* ]]; then
    os_str=linux
    arch=amd64
    ostype=Linux
elif [[ "$OSTYPE" == "darwin"* && $archdetect == "arm64" ]]; then
    os_str=darwin
    arch=arm64
    ostype=MacOS_arm64
elif [[ "$OSTYPE" == "darwin"* ]]; then
    os_str=darwin
    arch=amd64
    ostype=MacOS
elif [[ "$OSTYPE" == "freebsd"* ]]; then
    os_str=freebsd
    arch=amd64
    ostype=FreeBSD
    echo "FreeBSD support coming soon..."
    exit 1
else
    echo "${RED}Unsupported OS: $OSTYPE${RESET}"
    exit 1
fi
echo "${GREEN}OS is $ostype${RESET}"

dir=bin
echo "Creating a local $dir directory if not present..."
if [[ ! -e $dir ]]; then
    mkdir $dir
elif [[ ! -d $dir ]]; then
    echo "${RED}$dir already exists but is not a directory${RESET}" 1>&2
    exit 1
fi

echo "Checking Azure Environment Variables and Cloud Connector bootstrap requirements... For ZPA or custom/byo deployments, please stop and refer to the README and terraform.tfvars file instructions"
if [[ "$oper" == "up" && ! -e ./.zsecrc ]]; then
first_run="yes"
    echo "export zscaler_cloud='$zscaler_cloud'" > .zsecrc   
    # Azure Region selection
    PS3="${CYAN}Select desired Azure region: ${RESET}"
    region_list=(
	"australiacentral"
	"australiacentral2"
	"australiaeast"
	"australiasoutheast"
	"brazilsouth"
	"brazilsoutheast"
	"canadacentral"
	"canadaeast"
	"centralindia"
	"centralus"
	"centraluseuap"
	"chinaeast"
	"chinaeast2"
	"chinaeast3"
	"chinanorth"
	"chinanorth2"
	"chinanorth3"
	"eastasia"
	"eastus"
	"eastus2"
	"eastus2euap"
	"francecentral"
	"francesouth"
	"germanynorth"
	"germanywestcentral"
	"japaneast"
	"japanwest"
	"koreacentral"
	"koreasouth"
	"northcentralus"
	"northeurope"
	"norwayeast"
	"norwaywest"
	"southafricanorth"
	"southafricawest"
	"southcentralus"
	"southeastasia"
	"southindia"
    "spaincentral"
	"swedencentral"
	"swedensouth"
	"switzerlandnorth"
	"switzerlandwest"
	"uaecentral"
	"uaenorth"
	"uksouth"
	"ukwest"
	"usdodcentral"
	"usdodeast"
	"usgovarizona"
	"usgovtexas"
	"usgovvirginia"
	"usseceast"
	"ussecwest"
	"ussecwestcentral"
	"westcentralus"
	"westeurope"
	"westindia"
	"westus"
	"westus2"
	"westus3"
    )
    select region_selection in "${region_list[@]}"; do
        for region_choice in "${region_list[@]}"; do
            if [[ $region_choice == $region_selection ]]; then
                azure_location=$region_selection
                echo "Azure region ${GREEN}$azure_location${RESET} selected..."
                echo "export TF_VAR_arm_location='$azure_location'" >> .zsecrc
		        if [[ ${azure_location} = "china"*  ]]; then
            		echo "${YELLOW}Azure China region detected. Setting ARM_ENVIRONMENT...${RESET}"
            		echo "export ARM_ENVIRONMENT=china" >> .zsecrc
            		echo "export ARM_SKIP_PROVIDER_REGISTRATION=true" >> .zsecrc
        	    elif [[ ${azure_location} = "usgov"* || ${azure_location} = "ussec"* || ${azure_location} = "usdod"* ]]; then
            		echo "${YELLOW} US Gov region detected. Setting ARM_ENVIRONMENT...${RESET}"
           	        echo "export ARM_ENVIRONMENT=usgovernment" >> .zsecrc
            		echo "export ARM_SKIP_PROVIDER_REGISTRATION=true" >> .zsecrc
        	    fi
                break 2
            fi
        done
    done

    echo "Checking Azure Environment Variables..."
    read -r -p "${CYAN}Enter Azure Subcription ID: ${RESET}" azure_subscription_id
    echo "export ARM_SUBSCRIPTION_ID=${azure_subscription_id}" >> .zsecrc
    echo "export TF_VAR_env_subscription_id=${azure_subscription_id}" >> .zsecrc
    read -r -p "${CYAN}Enter Directory (tenant) ID: ${RESET}" azure_tenant_id
    echo "export ARM_TENANT_ID=${azure_tenant_id}" >> .zsecrc
    read -r -p "${CYAN}Enter Application (client) ID of Service Principal: ${RESET}" azure_client_id
    echo "export ARM_CLIENT_ID=${azure_client_id}" >> .zsecrc
    read -r -p "${CYAN}Enter Client Secret Value of Service Principal: ${RESET}" azure_client_secret
    echo "export ARM_CLIENT_SECRET='${azure_client_secret}'" >> .zsecrc

    if [[ "$deployment" == "greenfield" ]]; then    
        while true; do
            clientpublicip=$(curl -s ifconfig.me)
            echo "greenfield deployments include a publicly accessible ssh bastion host.."
            read -r -p "${CYAN}Your current public IP is ${clientpublicip}. Restrict SSH access to only this IP address? [yes/no]: ${RESET}" bastion_response
            case $bastion_response in 
            yes|y ) 
                echo "Updating Bastion NSG to permit SSH only from ${clientpublicip}: "
                echo "export TF_VAR_bastion_nsg_source_prefix=${clientpublicip}" >> .zsecrc
                useclientip=true
            break
            ;;
            no|n )
                useclientip=false
            break
            ;;
            * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
            esac
        done

        if [[ "$useclientip" == "false" ]]; then
            while true; do
                read -r -p "${CYAN}Lock SSH access to a different IP address or range? Default is open [yes/no]: ${RESET}" changebastionip
                case $changebastionip in 
	            yes|y ) 
                    read -r -p "${CYAN}Enter new IP Address or CIDR range (e.g. 2.2.2.2/32): ${RESET}" bastionipinput
                    echo "export TF_VAR_bastion_nsg_source_prefix=${bastionipinput}" >> .zsecrc

                    if [[ $bastionipinput =~ ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/(3[0-2]|[1-2][0-9]|[1-9]))$ ]]
                    then
                        echo "$bastionipinput - IP/Netmask valid"
                    else
                        echo "${RED}$bastionipinput is not valid IP CIDR format${RESET}"
                        echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                        exit 1
                    fi
                break
                ;;
	            no|n )
                    echo "${YELLOW}**Caution** SSH access permitted for all IP addresses...${RESET}" 
                break
                ;;
	            * ) echo "${RED}invalid response. Please enter yes or no${RESET}";;
                esac
            done
        fi
    fi

    # if .zsecrc is not present we'll assume that Azure env was never set
    if [[ "$dtype" != "base" ]]; then
        # ---
        # Host Encryption Support
        encryption_at_host_enabled=true
        # Sourcing .zsecrc to use credentials during execution
        source .zsecrc
        if grep -q "export ARM_ENVIRONMENT=china" .zsecrc; then
        TOKEN_ENDPOINT="https://login.partner.microsoftonline.cn/${ARM_TENANT_ID}/oauth2/token"
        RESOURCE="https://management.chinacloudapi.cn"
        elif grep -q "export ARM_ENVIRONMENT=usgovernment" .zsecrc; then
        TOKEN_ENDPOINT="https://login.microsoftonline.us/${ARM_TENANT_ID}/oauth2/token"
        RESOURCE="https://management.usgovcloudapi.net"
        else
        TOKEN_ENDPOINT="https://login.microsoftonline.com/${ARM_TENANT_ID}/oauth2/token"
        RESOURCE="https://management.azure.com/"
        fi

        while true; do
            read -r -p "${CYAN}Do you want to enable the Azure host encryption feature? [Default setting is Yes]: ${RESET}" input

            # Convert the user input to lowercase for case-insensitive comparison
            input=$(echo "$input" | tr '[:upper:]' '[:lower:]')

            if [[ "$input" == "no" || "$input" == "n" ]]; then
                echo "${YELLOW}**Caution** Setting encryption_at_host_enabled to false...${RESET}"
                encryption_at_host_enabled=false
                break
            elif [[ "$input" == "yes" || "$input" == "y" || -z "$input" ]]; then            
                echo "Checking if EncryptionAtHost feature is enabled for subscription $ARM_SUBSCRIPTION_ID..."
                ACCESS_TOKEN=$(curl -s -X POST -H "Content-Type: application/x-www-form-urlencoded" \
                    -d "grant_type=client_credentials" \
                    -d "client_id=${ARM_CLIENT_ID}" \
                    -d "client_secret=${ARM_CLIENT_SECRET}" \
                    -d "resource=${RESOURCE}" \
                    "${TOKEN_ENDPOINT}" | grep -o '"access_token":"[^"]*' | awk -F'"' '{print $4}')
                    
                response=$(curl -s -X GET -H "Authorization: Bearer ${ACCESS_TOKEN}" \
                    "$RESOURCE/subscriptions/$ARM_SUBSCRIPTION_ID/providers/Microsoft.Features/providers/Microsoft.Compute/features/EncryptionAtHost?api-version=2021-07-01" \
                    |grep -o '"state":"[^"]*' | awk -F'"' '{print $4}')

                if [ "$response" = "Registered" ]; then
                    echo "Setting encryption_at_host_enabled to true..."
                    encryption_at_host_enabled=true
                else
                    echo "${RED}Error: Azure Subscription $ARM_SUBSCRIPTION_ID is not registered to support host encryption. Please refer to documentation.${RESET}"
                    exit 1    
                fi
                break
            else
                echo "${RED}Invalid input. Please enter 'yes' or 'no'.${RESET}"
            fi
        done

        echo "export TF_VAR_encryption_at_host_enabled=${encryption_at_host_enabled}" >> .zsecrc
        # End of Host Encryption support update
        # ---

        cc_instance_size=small
        echo "export TF_VAR_cc_instance_size=${cc_instance_size}" >> .zsecrc

        if [[ $cc_instance_size == "small" ]]; then
            PS3="${CYAN}Select desired Azure VM type for Cloud Connector: ${RESET}"
            if [[ "$azure_location" == "chinanorth" || "$azure_location" == "chinaeast" ]]; then
                vm_sizes=("Standard_DS2_v2")
                select ccvm_instance_type in "${vm_sizes[@]}"
                do
                    case $REPLY in
                        1)
                            echo "Cloud Connector VM type $ccvm_instance_type selected"
                            echo "export TF_VAR_ccvm_instance_type='$ccvm_instance_type'" >> .zsecrc
                            break
                            ;;
                        *) 
                            echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
            elif [[ "$azure_location" == "china"* ]]; then
                vm_sizes=("Standard_DS3_v2" "Standard_DS2_v2")
                select ccvm_instance_type in "${vm_sizes[@]}"
                do
                    case $REPLY in
                        1)
                            echo "Cloud Connector VM type $ccvm_instance_type selected"
                            echo "export TF_VAR_ccvm_instance_type='$ccvm_instance_type'" >> .zsecrc
                            break
                            ;;
                        2)
                            echo "Cloud Connector VM type $ccvm_instance_type selected"
                            echo "export TF_VAR_ccvm_instance_type='$ccvm_instance_type'" >> .zsecrc
                            break
                            ;;
                        *) 
                            echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
            else
                vm_sizes=("Standard_D2s_v3" "Standard_DS2_v2" "Standard_DS3_v2")
                select ccvm_instance_type in "${vm_sizes[@]}"
                do
                    case $REPLY in
                        1)
                            echo "Cloud Connector VM type $ccvm_instance_type selected"
                            echo "export TF_VAR_ccvm_instance_type='$ccvm_instance_type'" >> .zsecrc
                            break
                            ;;
                        2)
                            echo "Cloud Connector VM type $ccvm_instance_type selected"
                            echo "export TF_VAR_ccvm_instance_type='$ccvm_instance_type'" >> .zsecrc
                            break
                            ;;
                        3)
                            echo "Cloud Connector VM type $ccvm_instance_type selected"
                            echo "export TF_VAR_ccvm_instance_type='$ccvm_instance_type'" >> .zsecrc
                            break
                            ;;
                        *) 
                            echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
            fi
        fi

        read -r -p "${CYAN}Enter CC Provisioning URL${RESET} (E.g. connector.zscaler.net/api/v1/provUrl?name=azure_prov_url): " cc_vm_prov_url
        echo "Provisioning URL entered is: $cc_vm_prov_url. ${YELLOW}Make sure this matches the CC Instance Size $cc_instance_size chosen${RESET}"
        echo "export TF_VAR_cc_vm_prov_url=${cc_vm_prov_url}" >> .zsecrc
        read -r -p "${CYAN}Enter Azure Key Vault URL${RESET} (E.g https://zscaler-cc-demo.vault.azure.net): " azure_vault_url
        echo "Key Vault URL entered is: $azure_vault_url"
        echo "export TF_VAR_azure_vault_url=${azure_vault_url}" >> .zsecrc
        http_probe_port_default=50000
        read -r -p "${CYAN}Enter CC service health probe TCP port number. Valid input = 80 or any number between 1024-65535 [Default=$http_probe_port_default]: ${RESET}" http_probe_port_input
        http_probe_port=${http_probe_port_input:-$http_probe_port_default}
            if ((http_probe_port == 80 || http_probe_port >= 1024 && http_probe_port <= 65535)); then
                echo "${GREEN}Valid HTTP probe port input of $http_probe_port${RESET}"
                echo "export TF_VAR_http_probe_port=${http_probe_port}" >> .zsecrc
            else
                echo "${RED}Invalid HTTP probe port value${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi
        echo "Cloud Connector User Managed Identity Information:"

        while true; do
            echo "Terraform will lookup an existing User Managed Identity to assign to Cloud Connector resources..."
            read -r -p "${CYAN}Is the Managed Identity in the same Subscription ID? [yes/no]: ${RESET}" response
            case $response in 
            yes|y ) 
                echo "Managed Identity is in the same Subscription"
            break
            ;;
            no|n )
                read -r -p "${CYAN}Enter Subscription ID of Managed Identity: ${RESET}" managed_identity_subscription_id
                echo "export TF_VAR_managed_identity_subscription_id=${managed_identity_subscription_id}" >> .zsecrc
            break
            ;;
            * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
            esac
        done  
        read -r -p "${CYAN}Enter Managed Identity Name: ${RESET}" cc_vm_managed_identity_name 
        echo "export TF_VAR_cc_vm_managed_identity_name=${cc_vm_managed_identity_name}" >> .zsecrc
        read -r -p "${CYAN}Enter Managed Identity Resource Group: ${RESET}" cc_vm_managed_identity_rg
        echo "export TF_VAR_cc_vm_managed_identity_rg=${cc_vm_managed_identity_rg}" >> .zsecrc

        if [[ $dtype == *"vmss"* ]]; then
        echo "Function App User Managed Identity Information:"
            while true; do
                read -r -p "${CYAN}Assign the same User Managed Identity ($cc_vm_managed_identity_name) to Function App? [yes/no]: ${RESET}" function_mui_response
                case $function_mui_response in 
                yes|y ) 
                    echo "Terraform will associate the same Managed Identity to both the VMSS and Function App"
                    echo "export TF_VAR_function_app_managed_identity_name=${cc_vm_managed_identity_name}" >> .zsecrc
                    echo "export TF_VAR_function_app_managed_identity_rg=${cc_vm_managed_identity_rg}" >> .zsecrc
                break
                ;;
                no|n )
                    read -r -p "${CYAN}Enter Function App designated Managed Identity Name: ${RESET}" function_app_managed_identity_name 
                    echo "export TF_VAR_function_app_managed_identity_name=${cc_vm_managed_identity_name}" >> .zsecrc
                    read -r -p "${CYAN}Enter Function App designated Managed Identity Resource Group: ${RESET}" function_app_managed_identity_rg
                    echo "export TF_VAR_function_app_managed_identity_rg=${cc_vm_managed_identity_rg}" >> .zsecrc
                break
                ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done  
        fi

        cc_count_default=2
        if [[ "$dtype" == "base_1"* ]]; then
            echo "${GREEN}${dtype} will deploy one Cloud Connector in ${azure_location}${RESET}"
        elif [[ "$dtype" == *"vmss"* ]]; then
            echo "Auto Scaling deployment type identified. Proceeding to VMSS configurations..." 
        elif [[ "$dtype" == *"lb"* ]]; then
            read -r -p "${CYAN}Enter how many Cloud Connectors to deploy? [Default=$cc_count_default]: ${RESET}" cc_count_input
            cc_count=${cc_count_input:-$cc_count_default}
            if ((cc_count >= 1 && cc_count <= 20)); then
                echo "Terraform will deploy ${GREEN}${cc_count} Cloud Connectors${RESET} in ${azure_location}"
                echo "export TF_VAR_cc_count=${cc_count}" >> .zsecrc
            else
                echo "${RED}Invalid cc_count value. Must be a number between 1 and 20${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi
        fi

        az_supported_regions=["australiaeast","brazilsouth","canadacentral","centralindia","centralus","chinanorth3","eastasia","eastus","eastus2","francecentral","germanywestcentral","japaneast","koreacentral","northeurope","norwayeast","southafricanorth","southcentralus","southeastasia","spaincentral","swedencentral","switzerlandnorth","uaenorth","uksouth","westeurope","westus2","westus3","usgovvirginia"]
        if [[ ${az_supported_regions[*]} =~ $azure_location ]]; then
            echo "${GREEN}Azure region ${azure_location} supports Zones deployment...${RESET}"
            zones_enabled_default=no
            while true; do
                read -r -p "${CYAN}Deploy Cloud Connectors in dedicated Availability Zones/subnets? (Enter yes or no) [Default=$zones_enabled_default]: ${RESET}" zones_enabled_input
                zones_enabled=${zones_enabled_input:-$zones_enabled_default}
                case $zones_enabled in 
                yes|y )
                    echo "export TF_VAR_zones_enabled=true" >> .zsecrc
                    zones_enabled=true
                break
                ;;
                no|n )
                    echo "export TF_VAR_zones_enabled=false" >> .zsecrc
                    echo "${YELLOW}**Caution** No zones defined. Proceeding with availability sets fault tolerance...${RESET}"
                    break
                ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done  
        else
            echo "${YELLOW}Azure region ${azure_location} does not support Zones. Proceeding...${RESET}"
        fi
        # Azure number of Availability Zones selection
        if [[ "$zones_enabled" == "true" ]]; then
            if [[ "$dtype" == "base_1"* ]]; then
                echo "Single Cloud Connector Deployment can only specify a single zone"
                zones_count=1
            else
                PS3="${CYAN}Select how many Availability Zone subnets to deploy across: ${RESET}"
                zones_list=(
                    "1 availability zone"
                    "2 availability zones"
                    "3 availability zones"
                    )
                select zone_selection in "${zones_list[@]}"
                do
                    case $REPLY in
                    1 )
                        echo "One Availability Zone selected..."
                        zones_count=1
                    break
                    ;;
                    2 )
                        echo "Two Availability Zones selected..."
                        zones_count=2
                    break
                    ;;
                    3 )
                        echo "Three Availability Zones selected..."
                        zones_count=3
                    break
                    ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
            fi
            if [[ "$zones_count" < 3 ]]; then
                if [[ "$dtype" == "base_1"* ]]; then
                    PS3="${CYAN}Select which availablity zone to deploy in: ${RESET}"
                else
                    PS3="${CYAN}Select which availablity zones to deploy across: ${RESET}"
                fi
                if [[ "$zones_count" == 1 ]]; then
                    zones_options=(
                        "Zone 1"
                        "Zone 2"
                        "Zone 3"
                        )
                    select zones_selection in "${zones_options[@]}"
                    do
                        case $REPLY in
                        1 )
                            echo "Cloud Connector resources will be deployed in AZ 1"
                            echo "export TF_VAR_zones='[\"1\"]'" >> .zsecrc
                        break
                        ;;
                        2 )
                            echo "Cloud Connector resources will be deployed in AZ 2"
                            echo "export TF_VAR_zones='[\"2\"]'" >> .zsecrc
                        break
                        ;;
                        3 )
                            echo "Cloud Connector resources will be deployed in AZ 3"
                            echo "export TF_VAR_zones='[\"3\"]'" >> .zsecrc
                        break
                        ;;
                        *) 
                            echo "${RED}Invalid response. Please enter a number selection${RESET}"
                        esac
                    done
                else
                    zones_options=(
                        "Zones 1 and 2"
                        "Zones 1 and 3"
                        "Zones 2 and 3"
                        )
                    select zones_selection in "${zones_options[@]}"
                    do
                        case $REPLY in
                        1 )
                            echo "Cloud Connector resources will be deployed in AZ 1 and AZ 2"
                            echo "export TF_VAR_zones='[\"1\", \"2\"]'" >> .zsecrc
                        break
                        ;;
                        2 )
                            echo "Cloud Connector resources will be deployed in AZ 1 and AZ 3"
                            echo "export TF_VAR_zones='[\"1\", \"3\"]'" >> .zsecrc
                        break
                        ;;
                        3 )
                            echo "Cloud Connector resources will be deployed in AZ 2 and AZ 3"
                            echo "export TF_VAR_zones='[\"2\", \"3\"]'" >> .zsecrc
                        break
                        ;;
                        *) 
                            echo "${RED}Invalid response. Please enter a number selection${RESET}"
                        esac
                    done
                fi
            else
                echo "Cloud Connector resources will be deployed in AZ1, AZ 2 and AZ 3"
                echo "export TF_VAR_zones='[\"1\", \"2\", \"3\"]'" >> .zsecrc
            fi
        fi

        #Browfield/BYO Networking Options
        if [[ "$deployment" == "brownfield" ]]; then
            while true; do
                read -r -p "${CYAN}Enable Azure Private DNS for ZPA? (yes/no): ${RESET}" zpa_response
                case $zpa_response in 
                yes|y ) 
                    echo "Enabling Azure Private DNS module..."
                    zpa_enabled=true
                    echo "export TF_VAR_zpa_enabled=$zpa_enabled" >> .zsecrc
                break
                ;;
                no|n )
                    echo "No ZPA enablement..."
                    zpa_enabled=false
                    echo "export TF_VAR_zpa_enabled=$zpa_enabled" >> .zsecrc
                break
                ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done 
        fi

        if [[ "$zpa_enabled" == "true" || "$dtype" == *"zpa" ]]; then
            array=()
            domain_names_map="'{ "
            counter=0
            while true; do
                read -r -p "${CYAN}How many Domain/FQDN application segments to add to Private DNS Resolver Rules?: ${RESET}" domain_number
                if [[ $domain_number == 0 ]]; then
                    echo "${RED}Invalid input. Please enter a whole number for the number of domains you will be adding...${RESET}"
                elif [[ $domain_number =~ ^[0-9]+$ ]]; then
                    echo "$domain_number domains to enter..."
                break
                else
                    echo "${RED}Invalid input. Please enter a whole number for the number of domains you will be adding...${RESET}"
                fi
            done
            for i in $(seq $domain_number); do
                read -r -p "${CYAN}Enter a single ZPA Domain/FQDN ending with a trailing dot${RESET} ( e.g. azure.company.com. ): " domain_name
                if [[ $domain_name = *" "* ]]; then
                    echo "${RED}Spaces not allowed. Please enter only one domain at a time. Delete .zsecrc file and re-run zsec up...${RESET}"
                    exit 1
                elif [[ $domain_name == '' ]]; then
                    echo "${RED}Empty entries are not allowed. Delete .zsecrc file and re-run zsec up...${RESET}"
                    exit 1
                elif [[ $domain_name == "." ]]; then
                    echo "${YELLOW}You entered '.' dot. While Azure does support this to forward all domain requests, this could have unintended consequences/compatibility issues with Azure services${RESET}"
                elif [[ $domain_name == "."* ]]; then
                    echo "${RED}Invalid format. Domains cannot start with a dot (.). Delete .zsecrc file and re-run zsec up...${RESET}"
                    exit 1
                elif [[ $domain_name == "*"* ]]; then
                    echo "${RED}Invalid format. Domains cannot start with a star/wildcard (*). Delete .zsecrc file and re-run zsec up...${RESET}"
                    exit 1
                elif [[ $domain_name != *"." ]]; then
                    echo "${RED}Invalid format. Domains must end with a dot (.). Delete .zsecrc file and re-run zsec up...${RESET}"
                    exit 1
                fi
                array+=("$domain_name")
                counter=$(( $counter + 1 ))
                domain_names_map+="appseg$counter: \"$domain_name\", "
            done
            domain_names_map+="}'"
            echo "export TF_VAR_domain_names=$domain_names_map" >> .zsecrc
        fi

        # ZSSupport Server IP lookup by cloud to populate Security Group rule
        support_access_response_default="no"
        support_server_ip_default="199.168.148.101"
        while true; do
            read -r -p "${CYAN}By default, an outbound Network Security Group rule is configured enabling Zscaler remote support access. Would you like to disable this rule creation? [Default=$support_access_response_default]: ${RESET}" support_access_response_input
            support_access_response=${support_access_response_input:-$support_access_response_default}
            case $support_access_response in 
            yes|y ) 
                echo "${YELLOW}Outbound rule Zscaler_Support_Access will not be created${RESET}"
                echo "${YELLOW}*** Caution: Zscaler Support may not be able to assist as efficiently if troubleshooting is required without this access${RESET}"
                echo "export TF_VAR_support_access_enabled=false" >> .zsecrc
            break
            ;;
            no|n )
                echo "export TF_VAR_support_access_enabled=true" >> .zsecrc
                if [[ "$zs_env" == "development" ]]; then
                    echo "Setting security group rule to ${GREEN}$support_server_ip_default${RESET}"
                    echo "export TF_VAR_zssupport_server='$support_server_ip_default'" >> .zsecrc
                else
                    dns_commands=(
                        "dig +short remotesupport.$zscaler_cloud 2>/dev/null || true"
                        "getent ahostsv4 remotesupport.$zscaler_cloud 2>/dev/null | awk '{print \$1}' | head -1 || true"
                        "host remotesupport.$zscaler_cloud 2>/dev/null | awk '/has address/ { print \$4 ; exit }' || true"
                        "nslookup remotesupport.$zscaler_cloud 2>/dev/null | awk '/^Address: / { print \$2 ; exit }' || true"
                    )

                    for command in "${dns_commands[@]}"; do
                    support_server_ip=$(eval "$command")
                        if [[ $support_server_ip =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                            echo "${GREEN}Outbound rule permitting TCP/12002 access to $support_server_ip will be created${RESET}"
                            echo "export TF_VAR_zssupport_server='$support_server_ip'" >> .zsecrc
                            break
                        fi
                    done

                    if [[ $support_server_ip == '' ]]; then
                        if [[ "$zscaler_cloud" == "zscalerten.net" ]]; then
                            support_server_ip="136.226.24.62"
                        elif [[ "$zscaler_cloud" == "zscalergov.net" ]]; then
                            support_server_ip="136.226.16.141"
                        else
                            support_server_ip="199.168.148.101"
                        fi
                        echo "Unable to lookup ip for remotesupport.$zscaler_cloud. Defaulting to static mapping"
                        echo "${GREEN}Outbound rule permitting TCP/12002 access to $support_server_ip will be created${RESET}"
                        echo "${YELLOW}Caution: Verify that this IP is correct for your Zscaler Cloud $zscaler_cloud${RESET}"
                        echo "export TF_VAR_zssupport_server='$support_server_ip'" >> .zsecrc
                    fi
                fi
            break
            ;;
                * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
            esac
        done

        # VMSS specific inputs
        if [[ $dtype == *"vmss"* ]]; then
            if [[ "$zones_enabled" == "true" ]]; then
                echo "Explicit Availability Zones based deployed detected... Terrafrom will create a total of $zones_count VMSS; one per designated AZ"
            else
                echo "No explicit Availbility Zones were specified... Terraform will create a single VMSS"
            fi
            #########################################
            # Min/Default/Max VMSS Configuration
            #########################################
            # min count
            vmss_min_default=2
            read -r -p "${CYAN}Enter the minimum amount of Cloud Connectors per VMSS? [Default=$vmss_min_default]: ${RESET}" vmss_min_input
            vmss_min=${vmss_min_input:-$vmss_min_default}
            if (( $vmss_min < 1 || $vmss_min > 20 )); then
                echo "${RED}Invalid vmss_min value. Must be a number between 1 and 20${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi

            # default count
            vmss_default_default=2
            read -r -p "${CYAN}Enter the default amount of Cloud Connectors per VMSS? [Default=$vmss_default_default]: ${RESET}" vmss_default_input
            vmss_default=${vmss_default_input:-$vmss_default_default}
            if (( $vmss_default < 1 || $vmss_default > 20 )); then
                echo "${RED}Invalid vmss_default value. Must be a number between 1 and 20${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi

            # max count
            vmss_max_default=5
            read -r -p "${CYAN}Enter the maximum amount of Cloud Connectors per VMSS? [Default=$vmss_max_default]: ${RESET}" vmss_max_input
            vmss_max=${vmss_max_input:-$vmss_max_default}
            if (( $vmss_max < 1 || $vmss_max > 20 )); then
                echo "${RED}Invalid vmss_max value. Must be a number between 1 and 20${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi

            # validate values
            if (( $vmss_default < $vmss_min || $vmss_default > $vmss_max )); then
                echo "${RED}Invalid vmss_default value. Must be a number between vmss_min and vmss_max${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi

            if [[ "$zones_enabled" == "true" ]]; then
                echo "${dtype} will deploy $zones_count VMSS each with min: ${vmss_min} default: ${vmss_default} max: ${vmss_max} Cloud Connectors in ${azure_location}"
            else
                echo "${dtype} will deploy 1 VMSS with min: ${vmss_min} default: ${vmss_default} max: ${vmss_max} Cloud Connectors in ${azure_location}"
            fi
            echo "export TF_VAR_vmss_min_ccs=${vmss_min}" >> .zsecrc
            echo "export TF_VAR_vmss_default_ccs=${vmss_default}" >> .zsecrc
            echo "export TF_VAR_vmss_max_ccs=${vmss_max}" >> .zsecrc

            #########################################
            # Scale In/Out Threshold Configuration
            #########################################
            # Scale In threshold count
            scale_in_default=50
            read -r -p "${CYAN}Enter the scale in threshold for scale sets? This value refers to percent CPU utilization. [Default=$scale_in_default]: ${RESET}" scale_in_input
            scale_in=${scale_in_input:-$scale_in_default}
            if (( $scale_in < 1 || $scale_in > 100 )); then
                echo "${RED}Invalid scale_in value. Must be a number between 1 and 100${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi

            # Scale Out threshold count
            scale_out_default=70
            read -r -p "${CYAN}Enter the scale out threshold for scale sets? This value refers to percent CPU utilization. [Default=$scale_out_default]: ${RESET}" scale_out_input
            scale_out=${scale_out_input:-$scale_out_default}
            if (( $scale_out < 1 || $scale_out > 100 || $scale_out <= $scale_in)); then
                echo "${RED}Invalid scale_out value. Must be a number between 1 and 100 and be greater than scale_in value${RESET}"
                echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                exit 1
            fi

            echo "export TF_VAR_scale_in_threshold=${scale_in}" >> .zsecrc
            echo "export TF_VAR_scale_out_threshold=${scale_out}" >> .zsecrc

            #########################################
            # Scheduled Scaling Configuration
            #########################################
            # enable/disable scheduled scaling
            while true; do
                read -r -p "${CYAN}Do you want to enable scheduled scaling on the VMSS? [yes/no]: ${RESET}" response
                case $response in 
                    no|n ) 
                        echo "Skipping scheduled scaling configuration."
                        break
                        ;;
                    yes|y )
                        # min count
                        vmss_sched_min_default=2
                        read -r -p "${CYAN}Enter the minimum amount of scheduled Cloud Connectors in VMSS? [Default=$vmss_sched_min_default]: ${RESET}" vmss_sched_min_input
                        vmss_sched_min=${vmss_sched_min_input:-$vmss_sched_min_default}
                        if (( $vmss_sched_min < 1 || $vmss_sched_min > 20 )); then
                            echo "${RED}Invalid vmss_sched_min value. Must be a number between 1 and 20${RESET}"
                            echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                            exit 1
                        elif (( $vmss_sched_min > $vmss_max )); then
                            echo "${RED}Invalid vmss_sched_min value. Must be a number between less than or equal to vmss_max${RESET}"
                            echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                            exit 1
                        fi

                        # days of the week
                        days_of_week=()
                        potential_days_of_week=("Sunday" "Monday" "Tuesday" "Wednesday" "Thursday" "Friday "Saturday)
                        for day in ${potential_days_of_week[@]}; do
                            while true; do
                                read -r -p "${CYAN}Apply Scheduled Scaling Policy on ${day}? [yes/no]: ${RESET}" resp
                                case $resp in 
                                    no|n ) 
                                        echo "Not configuring ${day} on Scheduled Scaling configuration."
                                        break
                                        ;;
                                    yes|y )
                                        echo "Adding ${day} on Scheduled Scaling configuration."
                                        days_of_week+=($day)
                                        break
                                        ;;
                                    * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                                esac
                            done
                        done
                        #format days of week array into list
                        days_of_week_str="'["
                        print_str=""
                        for day in ${days_of_week[@]}; do
                            days_of_week_str+="\"${day}\", "
                            print_str+="${day} "
                        done
                        days_of_week_str+="]'"
                        echo "Configuring the following days on the Scheduled Scaling Policy: ${print_str}"
                        
                        # start time hour
                        start_hour_default=9
                        read -r -p "${CYAN}Enter the start time hour for the scheduled scaling configuration? [Default=$start_hour_default]: ${RESET}" start_hour_input
                        start_hour=${start_hour_input:-$start_hour_default}
                        if (( $start_hour < 0 || $start_hour > 23 )); then
                            echo "${RED}Invalid start_hour value. Must be a number between 0 and 23${RESET}"
                            echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                            exit 1
                        fi
                        # start time minute
                        start_min_default=0
                        read -r -p "${CYAN}Enter the start time min for the scheduled scaling configuration? [Default=$start_min_default]: ${RESET}" start_min_input
                        start_min=${start_min_input:-$start_min_default}
                        if (( $start_min < 0 || $start_min > 59 )); then
                            echo "${RED}Invalid start_min value. Must be a number between 0 and 59${RESET}"
                            echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                            exit 1
                        fi
                        # end time hour
                        end_hour_default=17
                        read -r -p "${CYAN}Enter the end time hour for the scheduled scaling configuration? [Default=$end_hour_default]: ${RESET}" end_hour_input
                        end_hour=${end_hour_input:-$end_hour_default}
                        if (( $end_hour < 0 || $end_hour > 23 )); then
                            echo "${RED}Invalid end_hour value. Must be a number between 0 and 23${RESET}"
                            echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                            exit 1
                        fi
                        # end time minute
                        end_min_default=30
                        read -r -p "${CYAN}Enter the end time min for the scheduled scaling configuration? [Default=$end_min_default]: ${RESET}" end_min_input
                        end_min=${end_min_input:-$end_min_default}
                        if (( $end_min < 0 || $end_min > 59 )); then
                            echo "${RED}Invalid end_min value. Must be a number between 0 and 59${RESET}"
                            echo "${YELLOW}Delete .zsecrc file and re-run zsec up...${RESET}"
                            exit 1
                        fi

                        echo "export TF_VAR_scheduled_scaling_enabled=true" >> .zsecrc
                        echo "export TF_VAR_scheduled_scaling_vmss_min_ccs=${vmss_sched_min}" >> .zsecrc
                        echo "export TF_VAR_scheduled_scaling_days_of_week=${days_of_week_str}" >> .zsecrc
                        echo "export TF_VAR_scheduled_scaling_start_time_hour=${start_hour}" >> .zsecrc
                        echo "export TF_VAR_scheduled_scaling_start_time_min=${start_min}" >> .zsecrc
                        echo "export TF_VAR_scheduled_scaling_end_time_hour=${end_hour}" >> .zsecrc
                        echo "export TF_VAR_scheduled_scaling_end_time_min=${end_min}" >> .zsecrc
                        break
                        ;;
                    * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done

            #########################################
            # Azure Function Configuration
            #########################################

            # Azure Function Storage Account
            echo "By default, Terraform will create a new Azure Storage Account to store the Function App"
            while true; do
                read -r -p "${CYAN}Do you have an existing Storage Account to use instead? [yes/no]: ${RESET}" existing_str_response
                case $existing_str_response in 
                    no|n ) 
                        echo "Terraform will proceed with creating a new Storage Account for Function App"
                        echo "export TF_VAR_existing_storage_account=false" >> .zsecrc
                        break
                        ;;
                    yes|y )
                        echo "Terraform will use an existing Storage Account. *Note* - Storage Account must reside in the same Subscription"
                        echo "export TF_VAR_existing_storage_account=true" >> .zsecrc
                        read -r -p "${CYAN}Enter the Name of your existing Storage Account: ${RESET}" existing_storage_account_name 
                        echo "export TF_VAR_existing_storage_account_name=${existing_storage_account_name}" >> .zsecrc
                        read -r -p "${CYAN}Enter the Resource Group of your existing Storage Account: ${RESET}" existing_storage_account_rg
                        echo "export TF_VAR_existing_storage_account_rg=${existing_storage_account_rg}" >> .zsecrc
                        echo "Azure Function App will use Storage Account: $existing_storage_account_name in RG: $existing_storage_account_rg"
                        break
                        ;;
                    * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done

            asp_flex_consumption_supported_regions=(
                "australiaeast"
                "eastasia"
                "eastus"
                "eastus2"
                "northeurope"
                "southcentralus"
                "southeastasia"
                "swedencentral"
                "uksouth"
                "westus2"
                "westus3"
                )

            # asp dynamic selection option
            asp_all="Y1 B1 EP1"
            asp_no_flex="B1 EP1"

            # Select App Service Plan SKU for function app
            PS3="${CYAN}Select App Service Plan SKU: ${RESET}"
            
            if [[ ${asp_flex_consumption_supported_regions[@]} =~ $azure_location ]]; then
                #display options for flex consumption, basic, and premium
                asp_sku_names=($asp_all)

            else
                # display only basic and premium options
                asp_sku_names=($asp_no_flex)
            fi
            select asp_sku_name_selection in "${asp_sku_names[@]}"; 
                do
                    case $asp_sku_name_selection in
                    Y1 )
                        echo "SKU Name ${GREEN}$asp_sku_name_selection${RESET} selected..."
                        echo "export TF_VAR_asp_sku_name='$asp_sku_name_selection'" >> .zsecrc
                    break
                    ;;
                    B1 )
                        echo "SKU Name ${GREEN}$asp_sku_name_selection${RESET} selected..."
                        echo "export TF_VAR_asp_sku_name='$asp_sku_name_selection'" >> .zsecrc
                    break
                    ;;
                    EP1 )
                        echo "SKU Name ${GREEN}$asp_sku_name_selection${RESET} selected..."
                        echo "export TF_VAR_asp_sku_name='$asp_sku_name_selection'" >> .zsecrc
                    break
                    ;;
                    *) 
                        echo "${RED}Invalid response. Please enter a number selection${RESET}"
                    esac
                done
             
            # Azure Function Public URL
            echo "By default, Terraform will upload the Zscaler CC Azure Function Zip to this Storage Account Blob for Function App retrieval"
            while true; do
                read -r -p "${CYAN}Do you have a different public URL to retrieve Zscaler CC Azure Function Zip from? [yes/no]: ${RESET}" func_public_url_response
                case $func_public_url_response in 
                    no|n ) 
                        echo "Terraform will proceed with uploading Function Zip file to Azure Storage"
                        echo "export TF_VAR_upload_function_app_zip=true" >> .zsecrc
                        break
                        ;;
                    yes|y )
                        echo "Terraform will not upload Function Zip..."
                        read -r -p "${CYAN}Enter an external URL to retrieve Zscaler CC Azure Function Zip from: ${RESET}" func_public_url_input
                        echo "export TF_VAR_zscaler_cc_function_public_url=${func_public_url_input}" >> .zsecrc
                        break
                        ;;
                    * ) echo "${RED}Invalid response. Please enter yes or no${RESET}";;
                esac
            done
        fi
    fi
fi

 #add local bin directory to PATH
if ! grep -Fxq "export PATH=\${PATH}:\${PWD}/bin" .zsecrc; then
    echo 'export PATH=${PATH}:${PWD}/bin' >> .zsecrc
fi

# add deployment type to .zsecrc for future runs
if [[ "$oper" == "up" ]]; then
    echo "${GREEN}Updating .zsecrc with dtype of $dtype${RESET}"
    sed -i'' -e '/dtype/d' .zsecrc
    echo "export dtype=${dtype}" >> .zsecrc
fi

# initialize environment variables
. ./.zsecrc

# check for valid environment variables in .zsecrc
if [ -z "$ARM_CLIENT_ID" ] || [ -z "$ARM_CLIENT_SECRET" ] || [ -z "$ARM_SUBSCRIPTION_ID" ] || [ -z "$ARM_TENANT_ID" ] || [ -z "$TF_VAR_arm_location" ]; then
    echo "${RED}Azure Access info is missing. Remove .zsecrc file and rerun $0 $1${RESET}"
    exit 1
fi

if [[ $dtype != "base" ]]; then
    echo "Checking Cloud Connector provisioning info"
    if [ -z "$TF_VAR_cc_vm_prov_url" ] || [ -z "$TF_VAR_azure_vault_url" ] || [ -z "$TF_VAR_http_probe_port" ] || [ -z "$TF_VAR_ccvm_instance_type" ] || [ -z "$TF_VAR_cc_vm_managed_identity_name" ] || [ -z "$TF_VAR_cc_vm_managed_identity_rg" ]; then
        echo "${RED}Cloud Connector provisioning info is missing. Remove .zsecrc file and rerun $0 $1${RESET}"
        exit 1
    fi
fi


echo "Download terraform binary for $ostype if not present..."
if [[ ! -e ./$dir/terraform ]]; then
    curl -o ./$dir/terraform_${tversion}_${arch}.zip https://releases.hashicorp.com/terraform/$tversion/terraform_${tversion}_${os_str}_${arch}.zip
    unzip ./$dir/terraform_${tversion}_${arch}.zip -d ./$dir
    rm -f ./$dir/terraform_${tversion}_${arch}.zip
fi

if [[ "$oper" == "do" ]]; then
    exit 1
fi

# Terraform apply/destroy
if [[ "$oper" == "up" ]]; then
    echo "${GREEN}Bringing up Cloud Connector cluster...${RESET}"
    TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" init
    if [[ "$AUTO_APPROVE" ]]; then
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" apply -auto-approve
    else
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" apply
    fi

elif [[ "$oper" == "destroy" ]]; then
    echo "${GREEN}Destroying Cloud Connector cluster...${RESET}"
    TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" init
    if [[ "$AUTO_APPROVE" ]]; then
        TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" destroy -auto-approve
    else
      TF_DATA_DIR=../.terraform ./$dir/terraform -chdir="$dtype" destroy
    fi
    echo "${GREEN}Removing Terraform files and directories...${RESET}"
    rm -rf bin 
    rm -rf **/.terraform/* && rm -rf **/.terraform*
    find . -type f -name '.terraform.lock.hcl' -delete
    rm -rf .terraform* && rm -f terraform.tfstate*
    rm -f *.pem && rm -f *.pem.pub
    rm -f name_prefix random_string
    rm -rf user.key user.crt
    rm -rf systems.json setup-*.tar
    rm -rf **/errorlog.txt
    now=$(date +'%Y-%m-%d-%H_%M_%S')
    echo "${GREEN}archiving .zsecrc file to .zsecrc-${now}${RESET}"
    cp .zsecrc .zsecrc-${now}
    rm -rf .zsecrc && rm -rf .zsecrc.bak
fi
